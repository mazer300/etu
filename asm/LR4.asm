.model small

.stack 400h

.data
    KEEP_IP DW 0        ; Для хранения смещения
    KEEP_CS DW 0        ; Для хранения сегмента

    EOFLine EQU '$'     ; Определение символьной константы 'Конец строки';

	welcome_str db 'Введите строку:', 0ah, 0dh, EOFLine                              ; Привествующая строка
    change db "Нажмите любую клавишу для вызова изменённого 09H", 0ah, 0dh, EOFLine  ; Сообщения о замене 9h

    input_head DB 64H, 0                        ; Заголовок строки: можно ввести максимум 64h=100 символов.
                                                ; В след байте вместо 0 появится фактическое количество введённых символов
    input DB 64H DUP('*'), 0ah, 0dh, EOFLine    ; Буфер памяти для введённых символов
                                                ; плюс байты для корректного завершения вывода
    output DB 64H DUP('$'), 0ah, 0dh, EOFLine   ; Буфер памяти для обработанных символов
                                                ; плюс байты для корректного завершения вывода

.code
    mov   ax,@data            ; Загрузка сегментного
    mov   ds,ax               ; регистра данных

    ; Вывод привествия
    mov dx, OFFSET welcome_str
	mov ah, 09h               ; Функция DOS для вывода строки
    int 21h    

    ; Ввод строки пользователем
    mov dx, OFFSET input_head
    call stringRead

    ; Сохранение позиций старого обработчика прерывания 9h
    mov ah, 35h               ; Функция получения вектора
    mov al, 9h                ; Номер вектора
    int 21h
    mov KEEP_CS, es           ; Запоминание сегмента оригинального обработчика
    mov KEEP_IP, bx           ; Запоминание смещения оригинального обработчика

    ; Задержка во времени
    mov cx, 0eh               ; 14 * 65535 мкс задержки
    mov dx, 0ffffh            ; Ещё 65535 мкс задержки
    mov ah, 86h               ; Функция "ждать"
    int 15h                   ; Вызов функции ожидания

    ; Замена обработчика прерывания 9h
    push ds
    mov dx, OFFSET SUBR_INT   ; Смещение для процедуры в DX новый обработчик SUBR_INT
    mov ax, SEG SUBR_INT      ; Сегмент процедуры
    mov ds, ax                ; Помещаем в DS
    mov ah, 25h               ; Функция установки вектора
    mov al, 09h               ; Номер вектора
    int 21h                   ; Меняем прерывание
    pop ds
    
    ; Сообщение об ожидании
    lea dx, change
    call  writeMsg	

	; Ожидание нажатия Enter
wait_for_enter:
	mov ah, 0h                ; Функция "проверка клавиши"
	int 16h                   ; Вызываем прерывание для чтения клавиши
	cmp ah, 1Ch               ; Проверяем, что нажата клавиша Enter (код 0x0D)
	jne wait_for_enter        ; Если нет, продолжаем ожидание

    ; Восстановление 9h
    push ds
    mov dx, KEEP_IP           ; Смещение для оригинального обработчика 9h
    mov ax, KEEP_CS           ; Сегмент оригинального обработчика
    mov ds, ax                ; Помещаем в DS
    mov ah, 25h               ; Функция установки вектора прерывания
    mov al, 9h                ; Номер вектора
    int 21h                   ; Замена прерывания
    pop ds

    ; Завершение программы
    mov ah, 4ch
    int 21h

; Процедура считывания строки
StringRead PROC NEAR
    ; Запоминание изменяемых регистров
    push ax
	push bp
	push bx
	
	mov ah, 0ah                       ; Функция ввода строка
	push dx                           ; Смещение заголовка строки
	int 21h                           ; Вызов функции DOS ввода строки
	pop bp                            ; Поместить в bp
	xor bx, bx                        ; Обнуление bx
	mov BL, ds:[bp + 1]               ; Теперь в bx количество введенных символов
	add bx, bp                        ; Теперь bx указывает на конечный введённый символ
	add bx, 2                         ; Теперь bx указывает на байт, следующий за финальным 0dh
	mov word ptr [bx + 1], 240ah      ; Добавить в конец 0ah и '$'

	; Возвращение сохраненных регистров
	pop bx
	pop bp
	pop ax
	ret
StringRead ENDP

; Процедура вывода сообщения
writeMsg  PROC  NEAR
	push ax             ; Запоминание изменяемого регистра
    mov ah, 09h         ; Функция DOS для вывода строки
    int 21h             ; Вызов DOS
    pop ax              ; Выгрузка изменяемого регистра
    ret
writeMsg  ENDP

; Процедура обработки строки
process_string PROC NEAR
	; Запоминание изменяемых регистров
	push si
	push di
	push bx
	push cx
	push dx
	push ax
	push es

	; Загрузка сегмента данных в регистр es
	mov ax, @data
	mov es, ax

	cld                     ; Сброс флага DF для направления слева направо

	lea si, input           ; Адрес области "откуда"
	lea di, output          ; Адрес области "куда"

	xor cx, cx              ; Обнуление регистра cx
	mov cl, input_head[1]   ; сх - размер строки
	
	cmp cl, 0               ; если строка пустая, то закончить
	je leave

	; Инициализация переменных
	xor dx, dx              ; bx будет использоваться для подсчета символов после "V"
	xor bx, bx

process_loop:
	lodsb                   ; Загрузить символ из si в al
	cmp al, 'V'             ; Проверка, является ли символ "V"
	jne next_char           ; Если нет, перейти к следующему символу

	; Нашли "V", теперь нужно найти максимальное число символов после него, образующих префикс
	push si                 ; Сохранить текущую позицию в строке
	mov dx, 0               ; Сбросить счетчик символов после "V"
	mov bx, 0               ; Сбросить смещение
	mov al, [si]            ; Загрузить символ из si в al
	
while:
	cmp al, '$'             ; Проверка на конец строки
	je append
	
	cmp al, input[bx]       ; Проверка на совпадение символов
	jne append
	
	inc bx                  ; Увеличения смещения
	inc dx                  ; Увеличение счётчика
	mov al,[si+bx]          ; Загрузить символ из si в al
	jmp while
	
append:
	pop si                  ; Восстановить текущую позицию в строке
	mov al, dl              ; Загрузить число символов в al
	cmp al,9                ; Если число двухзначное
	jle less_than_10
	
	; Преобразование числа больше 9 в строку
	mov bx, 10              ; Делитель
	xor dx, dx              ; Очистка dx для деления
	mov ah, 0               ; Очистка ah для верного результата деления
	div bx                  ; Делим ax на 10, частное в ax, остаток в dx
	add al, '0'             ; Преобразовать частное в символ
	mov [di], al            ; Сохранить символ в output
	inc di                  ; Перейти к следующей позиции в строке
	add dl, '0'             ; Преобразовать остаток в символ
	mov [di], dl            ; Сохранить символ в output
	inc di                  ; Перейти к следующей позиции в строке
	mov al, ' '             ; Добавить пробел после числа
	stosb                   ; Сохранить пробел в output
	jmp next_char           ; Перейти к следующему символу
	
less_than_10:
	add al, '0'             ; Преобразовать число в символ
	stosb                   ; Сохранить символ в output
	mov al, ' '             ; Добавить пробел после числа
	stosb                   ; Сохранить пробел в output
	jmp next_char           ; Перейти к следующему символу

next_char:
	loop process_loop       ; Продолжить обработку следующего символа пока cx>0
	
leave:
	; Завершение строки output
	dec di                  ; Убрать последний пробел
	mov al, '$'             ; Добавить символ конца строки
	stosb                   ; Сохранить символ конца строки в output

	; Вывод преобразованной строки
	mov dx, offset output
	call writeMsg

	; Возвращение сохраненных регистров
	pop es
	pop ax
	pop dx
	pop cx
	pop bx
	pop di
	pop si
	ret
process_string ENDP

; Обработчик прерывания 9h
SUBR_INT proc
    ; Сохранение изменяемых регистров
	push ax
    push es
    push bx
    push ds
    push dx

	; Преобразование строки
	call process_string
	 
	; Восстановление 9h
	push ds
    mov dx, KEEP_IP            ; Смещение для оригинального обработчика 9h
    mov ax, KEEP_CS            ; Сегмент оригинального обработчика
    mov ds, ax                 ; Помещаем в DS
    mov ah, 25h                ; Функция установки вектора прерывания
    mov al, 9h                 ; Номер вектора
    int 21h                    ; Замена прерывания
    pop ds
	
	; Возвращение сохраненных регистров
    pop dx
    pop ds
    pop bx
    pop es
    pop ax
	
    jmp dword ptr [KEEP_IP]    ; Переход к выполнению оригинального кода обработки прерывания 9h

SUBR_INT endp

end
